<!DOCTYPE html>
<meta charset="utf-8">

<style>
.node circle {
  fill: #fff;
  stroke: black;
  stroke-width: 1.5px;
}

.node {
  font: 10px sans-serif;
}

.recruiter {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

.root circle {
  fill: #9467bd;
  stroke: black;
  stroke-width: 1.5px;
}

.parent {
  stroke: blue;
  fill: none;
}

</style>

<body>
</body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var diameter = 2*window.innerWidth + 240;

var tree = d3.layout.tree()
    .size([window.innerHeight, window.innerWidth])
    .separation(function(a, b) { return 5*(a.parent == b.parent ? 1 : 2) / a.depth; });

var diagonal = d3.svg.diagonal.radial()
    .projection(function(d) {return [d.y, d.x / 180 * Math.PI]; });
    
var svg = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter - 150)
  .append("g")
    .attr("transform", "translate(" + 0.15*diameter + "," + 0.15*diameter + "),scale(0.3)");


d3.csv("matchnet_trim.csv", function(edges) {
  var rds_edges = edges
    .filter(function(d) { return d["UniqueID1_recruiter"] != "" && d["UniqueID1"] != d["UniqueID1_recruiter"] })
    .map(function(d) { return { source: d["UniqueID1_recruiter"], target: d["UniqueID1"] } })
  
  var h = graphHierarchy(rds_edges)

  var nodes = tree.nodes(h),
      rds_links = tree.links(nodes);

  var rec = svg.selectAll("path.recruiter")
      .data(rds_links)
    .enter().append("path")
      .attr("class", "recruiter")
      .attr("d", diagonal);
  

  /* Root */
  var root = svg.append("g")
      .attr("class", "root")
      .attr("transform", "translate(" + nodes[0].y + ")")
  root.append("circle")
      .attr("r", 50)
  
  /* All children */
  
  
  var node = svg.selectAll("g.node")
      .data(nodes.slice(1))
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })  

  node.append("circle")
    .attr("r", 10);
    
    
  var nodesByName = {}
  for (d of nodes)
    nodesByName[d.name] = d
    
    
  var nontree_nodes  = [], par_links = []
  
  for (d of edges) {
    var id = d["UniqueID1"]
    var parent = d["ParentUniqueID1"]
    
    if(id == parent)
      continue;
  
    
    var tar = nodesByName[id]
    if (!tar) {
      continue;
      //tar = {name: id}
      //nodesByName[id] = tar
      //nontree_nodes.push(tar)
    }
    
    var src = nodesByName[parent]
    if (!src) {
      src = {name: parent, x: 0, y: 0}
      nodesByName[parent] = src
      nontree_nodes.push(src)
    }
    
    par_links.push({source: src, target: tar})
  }
  
  
  var par = svg.selectAll(".parent")
    .data(par_links)
   .enter().append("path")
    .attr("class", "parent")
    .attr("d", diagonal)
  
  var nontree = svg.selectAll("g.node.nontree")
      .data(nontree_nodes)
    .enter().append("g")
      .classed({node: 1, nontree: 1})
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; }) 
  

  nontree.append("circle")
    .attr("r", "50");
  
  
  var nontree_map = d3.map(nontree_nodes, function(d) { return d.name })
    
  var nontree_links = par_links.filter(function(d) { return nontree_map.get(d.source.name) || nontree_map.get(d.target.name) })
 
 
  var force = d3.layout.force()
    .charge(-120)
    .linkDistance(30)
    .size([diameter, diameter-150])
    .nodes(nontree_nodes)
    .links(nontree_links) 
  
  console.log(nontree_nodes)
  //thunk() 
  force.on("tick", function() {
    nontree
    .attr("transform", function(d) { console.log(d); thunk() ; return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; }) 
    
    par.attr("d", diagonal)
  })
  
  force.start()
    
  
  
  
  

 
  
})


function graphHierarchy(edges) {
  var nodesById = {}
  var nodes = []
  
  function idToNode(id) {
    if (nodesById[id])
      return nodesById[id]
    var node = {"name": id, "children": []}
    nodes.push(node)
    nodesById[id] = node;
    return node
  }
  
  edges.forEach(function(d) {
    var src = idToNode(d.source)
    var tar = idToNode(d.target)
    if (tar.parent) /* TODO: this means the dataset is weird */
      return
    src.children.push(tar)
    tar.parent = src
  })
  
  //var maxsz = 0;
  //var maxtree;
  var trees = []
  nodes.forEach(function(d) {
    if (!d.parent)
      trees.push(d)
    /*d.size = calcSize(d);
    if (d.size > maxsz) {
      maxsz = d.size
      maxtree = d
    }*/
  })

  function calcSize(tree) {
    if (!tree.children)
      return 1;
    var size = 1;
    tree.children.forEach(function(d) {
      size += calcSize(d)
    });
    return size;
  }
  
  var root = {"name": "Seeds", "children": trees}
  return root
}

</script>