<!DOCTYPE html>
<meta charset="utf-8">

<style>
.node circle {
  fill: #fff;
  stroke: black;
  stroke-width: 1.5px;
}

.node {
  font: 10px sans-serif;
}

.child circle {
  fill: red;
}

.recruiter {
  fill: none;
  stroke: grey;
  stroke-width: 1.5px;
}

.root circle {
  fill: darkred;
  stroke: black;
  stroke-width: 1.5px;
}

.parent {
  stroke: blue;
  fill: none;
}

</style>

<body>
</body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var diameter = 2*window.innerWidth + 240;

var tree = d3.layout.tree()
    .size([window.innerHeight, window.innerWidth])
    .separation(function(a, b) { return 5*(a.parent == b.parent ? 1 : 2) / a.depth; });

var diagonal = d3.svg.diagonal.radial()
    .projection(function(d) {return [d.y, d.x / 180 * Math.PI]; });
    
var svg = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter - 150)
  .append("g")
    .attr("transform", "translate(" + 0.15*diameter + "," + 0.15*diameter + "),scale(0.3)");


d3.csv("matchnet_trim.csv", function(edges) {
  var rds_edges = edges
    .filter(function(d) { return d["UniqueID1_recruiter"] != "" && d["UniqueID1"] != d["UniqueID1_recruiter"] })
    .map(function(d) { return { source: d["UniqueID1_recruiter"], target: d["UniqueID1"] } })
  
  var h = graphHierarchy(rds_edges)

  var nodes = tree.nodes(h),
      rds_links = tree.links(nodes);

  var rec = svg.selectAll("path.recruiter")
      .data(rds_links)
    .enter().append("path")
      .attr("class", "recruiter")
      .attr("d", diagonal);
  

  /* Root */
  var root = svg.append("g")
      .attr("class", "root")
      .attr("transform", "translate(" + nodes[0].y + ")")
  root.append("circle")
      .attr("r", 50)
  
  /* All children */
  
  
  var node = svg.selectAll("g.node")
      .data(nodes.slice(1))
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })  

  function distance(d) {
    if (d.children)
      for (x of d.children) {
        x.distance = d.distance + 1
        distance(x)
      }
  }
  nodes[0].distance = 0
  distance(nodes[0])

  var dom = d3.extent(nodes, function(d) { return d.distance })
  var color = d3.scale.linear()
      .domain(dom)
      .range(["red", "white"])
  
  node.append("circle")
    .attr("r", 10)
    .style("fill", function(d) { return color(d.distance) })
    .append("title")
    .text(function(d) { return d.name})
    
  var nodesByName = {}
  for (d of nodes)
    nodesByName[d.name] = d
  
  var  par_edges = edges
    .filter(function(d) { return nodesByName[d]})
  
  for (d of edges) {
    var id = d["UniqueID1"]
    var parent = d["ParentUniqueID1"]
    
    if(id == parent)
      continue;
  
    var tar = nodesByName[id], src = nodesByName[parent];
    
    if (!src || !tar)
      continue;
    
    if (!src.neighbors)
      src.neighbors = [tar]
    else
      src.neighbors.push(tar)
          
    par_edges.push({source: src, target: tar})
  }
  
  
  var par = svg.selectAll(".parent")
    .data(par_edges)
   .enter().append("path")
    .attr("class", "parent")
    .attr("d", diagonal)
  
  // hack -
  node.each(function(d) { d.circle = d3.select(this).select("circle") })

  node.on("mouseover", function(d) {
    function enchild(d, r) {
      d.circle.attr("r", Math.max(r, 10))
      if(d.children)
        for (x of d.children)
          enchild(x, r/2)
    }
    enchild(d, 50)
    
    if (d.neighbors)
      for (x of d.neighbors) {
        x.circle.attr("r", 35)
      }
    
  })
  
  node.on("mouseout", function() {
    node.selectAll("circle")
      .attr("r", 10)
  })
})


function graphHierarchy(edges) {
  var nodesById = {}
  var nodes = []
  
  function idToNode(id) {
    if (nodesById[id])
      return nodesById[id]
    var node = {"name": id, "children": []}
    nodes.push(node)
    nodesById[id] = node;
    return node
  }
  
  edges.forEach(function(d) {
    var src = idToNode(d.source)
    var tar = idToNode(d.target)
    if (tar.parent) /* TODO: this means the dataset is weird */
      return
    src.children.push(tar)
    tar.parent = src
  })
  
  var maxsz = 0;
  var maxtree;
  var trees = []
  nodes.forEach(function(d) {
    if (!d.parent)
      trees.push(d)
    d.size = calcSize(d);
    if (d.size > maxsz) {
      maxsz = d.size
      maxtree = d
    }
  })

  function calcSize(tree) {
    if (!tree.children)
      return 1;
    var size = 1;
    tree.children.forEach(function(d) {
      size += calcSize(d)
    });
    return size;
  }
  
  var root = {"name": "Seeds", "children": trees}
  return root
}

</script>