<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

.legend {
  position: absolute;
  top: 0;
  right: 0;
}

.controls {
  position: absolute;
  top: 10%;
  left: 2%;
}

.axis path {
    display: none;
}

.axis line {
    stroke: #000;
}



</style>
<title>Respondents-only network</title>
<body>
  <h2>Respondents-only network visualization</h2>
  <div class="controls">
    <div>
      Color by <br>   
     <input type="radio" name="colorby" value="kp">whether or not selected as key player<br>
     <div id="kpbox"></div>
     <input type="radio" name="colorby" value="btwn">betweenness score <br>
     <div id="btwnbox"></div>
     <input type="radio" name="colorby" value="bridge">bridging score 
     <div id="bridgebox"></div>
     <input type="radio" name="colorby" value="eigen">eigencentrality score 
     <div id="eigenbox"></div>
     <input type="radio" name="colorby" value="constraint">Burt's network constraint 
     <div id="constraintbox"></div>
     <input type="radio" name="colorby" value="ens">Burt's effective network size
      <div id="ensbox"></div>
    </div>
  </div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = window.innerWidth;
    height = window.innerHeight;

var force = d3.layout.force()
    .charge(-120)
    .gravity(0.3)
    .linkDistance(30)
    .size([width, height]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var colors = {}

// from process_Data.R: There are 302 FB respondents, but 291 of those have ties to other respondents
d3.json("graph_new.json", function(graph) {
  var nodesByName = {}
  
  var nodes = graph.nodes, links = graph.edges
  
  nodes.forEach(function(d) { nodesByName[d.name] = d })
  nodes.forEach(function(d) { d.kp = d.kp ? 1 : 0 })
  links.forEach(function(d) {
    d.source = nodesByName[d.source]
    d.target = nodesByName[d.target]
    if (!d.bridge)
      d.bridge = 0
  })

  console.log(nodes)

  colors["kp"] = makeLegend(nodes, "kp", d3.select("#kpbox"), "yellow");
  colors["btwn"] = makeLegend(nodes, "btwn", d3.select("#btwnbox"), "red")
  colors["bridge"] = makeLegend(nodes, "bridge", d3.select("#bridgebox"), "blue");
  colors["eigen"] = makeLegend(nodes, "eigen", d3.select("#eigenbox"), "green");
  colors["constraint"] = makeLegend(nodes, "constraint", d3.select("#constraintbox"), "purple");
  colors["ens"] = makeLegend(nodes, "ens", d3.select("#ensbox"), "orange");
  
  force
      .nodes(nodes)
      .links(links)
      .start();

  var link = svg.selectAll(".link")
      .data(links)
    .enter().append("line")
      .attr("class", "link")
      .style("stroke-width", function(d) { return Math.sqrt(d.value); });

  var node = svg.selectAll(".node")
      .data(nodes)
    .enter().append("circle")
      .attr("class", "node")
      .attr("r", 5)
      .style("fill", "grey")
      .call(force.drag);

  node.append("title")
      .text(function(d) { return d.name; });

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  });

    
  /* change colorby */
  d3.selectAll('input[name="colorby"]')
    .on("change", function() {
      var thing = d3.event.target.value
      node.transition().style("fill", function(d) { return colors[thing](d[thing])})
    })
});

function makeLegend(nodes, thing, home, topcol) {
  var lw = 200, lh=20, padding=20;
  
  var extent = d3.extent(nodes, function(d) { return d[thing]})

  var color = d3.scale.linear()
    .domain(extent)
    .range(["grey", topcol])

  var legend = home
    .append("svg")
    .attr("height", lh+padding)
    //.attr("width", lw+2*padding)
  
  legend.append("linearGradient")
      .attr({"id":"grad", "x1": "0%", "y1": "0%", "x2":"100%", "y2":"0%"})
      .selectAll("stop")
    .data(extent).enter()
      .append("stop")
      .attr("offset", function(_, i) { return (i*100).toString()+"%" })
      .style("stop-opacity", "1")
      .style("stop-color", color)


  legend.append("rect")
    .attr("width", lw)
    .attr("height", lh)
    .attr("x", padding)
    .style("fill", "url(#grad)")

  var lscale = d3.scale.linear()
    .domain(extent)
    .range([0, lw]);

  var format = d3.format("g")
  var axis = d3.svg.axis()
    .scale(lscale)
    .ticks(2)
    .tickFormat(format);

  legend.append("g")
    .attr("class", "axis")
      .attr("transform", "translate(" + padding + "," + lh +")")
      .call(axis);

  return color;
  
}
</script>
